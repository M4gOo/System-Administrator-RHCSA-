
================================================ TAR / STAR
 
 create an archive requires 3 steps
    Archiving - pack those files and dir into a single file backup.tar
    Compress the archive (makes smaller size of the original) backup.tar.gz
    Copy where you would keep your backup
  
before extract always check the content and the paths  
archive also store permissions and ownership info
 
 best way to use this utility is using tar --help
 
 #
 
 tar rf archive.tar file1    add a file to tar archive
 tar cf archive.tar Pictures/  create a tar file with entirely directory content to archive
 tar cf archive.tar /home/user/Pictures/  the content it be save with the path /home/user/Pictures/
 tar xf archive.tar -C /tmp/      it will extract in the path given
 sudo tar xf archive.tar -C /tmp/      it will extract in the path given and the ownership and permission it will be preserved
 star -zc -f=/home/bob/backup.star.gz ~/files
 z - gzip
 bz - bzip
 c - create
 f= - file
 t - list content in .start.gz              star -t -f=backup.star.gz
 
 tar cfj /home/bob/asset_backup.tar.bz2 --absolute-names /opt/assets/

================================================ FIND

#
find /opt/assets -type f -perm 2664 -exec cp -p {} /home/bob/specialfiles/ \;

SUID - 4
SGID - 2
Sticky bit - 1
-exec <command> {} \;
      find will execute <command> and will substitute {} with the filename(s) found. 
      with ; a single <command> for each file is executed 
      escaped here as \; to prevent the shell from interpreting it

{} \; : executing the commands for each found result
{} + : executing the command once with all results argument like this -> ls file1.txt file2.txt file3.txt



================================================ GREP

#
grep "passed" /home/bob/examresults > /home/bob/passed.txt
grep "failed" /home/bob/examresults > /home/bob/failed.txt


================================================ TUNED
Sysadmins can use the static profiles to define specific performance parameters or allow the system to switch profiles dynamically depending on the existing workload.
A profile is a set of rules that defines certain system parameters such as disk settings, kernel parameters, network optimization settings, and many other aspects of the system.


================================================ systemd targets
Targets in systemd act as synchronization points during the start of your system.
The purpose of target units is to group together various systemd units through a chain of dependencies.
The graphical.target unit for starting a graphical session, starts system services such as the GNOME Display Manager (gdm.service) or Accounts Service (accounts-daemon.service), 
and also activates the multi-user.target unit.

#
systemctl get-default
systemctl set-default
ls -l /usr/lib/systemd/system/

basic
unit target covering basic boot-up

rescue
unit target that pulls in the base system and spawns a rescue shell

multi-user
unit target for setting up a multi-user system

graphical
unit target for setting up a graphical login screen

emergency
unit target that starts an emergency shell on the main console. provides the most minimal environment possible and allows you to repair your system even 
in situations when the system is unable to enter rescue mode. In emergency mode, the system mounts the root file system only for reading, 
does not attempt to mount any other local file systems, does not activate network interfaces, and only starts a few essential services.

sysinit
unit target that pulls in the services required for system initialization


=============================================== niceness value
Niceness value is a number attached to processes in *nix systems   
is used to decide how much CPU time is allocated to it.
used to change the priority of a process, which, in effect, determines the urgency with which it is executed in the system. 
The nice command configures the priority of a Linux process before it is started. 
The renice command sets the priority of an already running process.

 -20 the highest priority
 +19 lowest
 
 By default, any Linux process created by a user has a nice value of 0
 
 check the nice (NI)
 #
 ps -l
 ps -le | grep <service>
 top
 
 #
 sudo renice -n <-20 to 19>  -p <PID>
 nice -nice_value command-arguments
 sudo renice -n 5 -u <username>       modify the priority of all processes owned by a group
 sudo renice -n 5 -g <groupname>      modify the priority of all processes owned by a user


============================================== swap 

Swap is a space on a disk that is used when the amount of physical RAM memory is full. When a Linux system runs out of RAM, 
inactive pages are moved from the RAM to the swap space.

Create a file that will be used for swap
If falllocate is not installed or if you get an error message 
#
sudo fallocate -l 1G /swapfile

use the following command to create the swap file
#
sudo dd if=/dev/zero of=/swapfile bs=1024 count=1048576

Only the root user should be able to write and read the swap file
#
sudo chmod 600 /swapfile

mkswap utility to set up the file as swap area
#
sudo mkswap /swapfile

Enable the swap (non permanent)
#
sudo swapon /swapfile

#
sudo vi /etc/fstab  (permanent)
/swapfile swap swap defaults 0 0

To verify that the swap is active
#
swapon

remove Swap File 
#
sudo swapoff -v /swapfile
Remove the swap file entry in /etc/fstab
sudo rm /swapfile

create a  file with empty zeros
#
sudo dd if=/dev/zero of=/swap bs=1M count=128 status=progress
dd will copy the if file to of, count means to write 1 megabyte block 128 times. it will be 128Megabytes

================================================================== partitions

Your hard drive is usually partitioned into logical volumes called partitions.
 
 check first the hard-disk and the partitions
 #
 lsblk
 
 #
 cfdisk /dev/sdb
 fdisk /dev/sdb
 
 
 ================================================================== LVM - https://web.mit.edu/rhel-doc/5/RHEL-5-manual/Cluster_Logical_Volume_Manager/LV_create.html
 
 #
 sudo pvcreate /dev/hdd                                     create a physical volume
 sudo vgcreate <volume_groupname> /dev/sda6 /dev/sda7       create a volume group (with two physical volumes)
 sudo lvcreate -l 100%FREE -n storage volume1               create a logical volume named storage using 100% of the free space on the volume group volume1
 sudo lvcreate -l 60%FREE -n storage volume1                 60% of the total space in volume group volume1
 
 
======================================================================== Create FileSystem

mkfs.xfs block-device


mount -t TYPE DEVICE_NAME DIRECTORY
-t option to specify the file system


 It instructs the operating system that filesystem is ready to use and associate it with a particular point in the system's hierarchy. 
 Mounting will make files, directories and devices available to the users.
The mount command is used to make a device or file system accessible to the system, and then to connect 
its root directory to a mount point on the local file system.

Mounting is the act of associating a storage device to a particular location in the directory tree. For example, when the system boots, a particular storage device (commonly called the root partition) is associated with the root of the directory tree, i.e., that storage device is mounted on / (the root directory).

Let's say you now want to access files on a CD-ROM. You must mount the CD-ROM on a location in the directory tree (this may be done automatically when you insert the CD). Let's say the CD-ROM device is /dev/cdrom and the chosen mount point is /media/cdrom. The corresponding command is

mount /dev/cdrom /media/cdrom
After that command is run, a file whose location on the CD-ROM is /dir/file is now accessible on your system as /media/cdrom/dir/file. When you've finished using the CD, you run the command umount /dev/cdrom or umount /media/cdrom (both will work; typical desktop environments will do this when you click on the “eject” or ”safely remove” button).


================================================================== crontab   ----- https://ostechnix.com/a-beginners-guide-to-cron-jobs/

sudo vi /etc/crontab

sudo crontab -e -u <username>


to check this list
Minute(0-59) Hour(0-23) Day_of_month(1-31) Month(1-12) Day_of_week(0-6) 0 Saturday 6 Sunday
cat /etc/crontab 

=================================================================== modules   ????????????????????????????????????

Reset the module stream for the container-tools package as below:
sudo yum -y module reset container-tools
Then use yum to install version 3.0 of the container-tools package with below command:


sudo yum -y module install container-tools:3.0 --skip-broken --allowerasing --nobest


================================================================== Stratis

Stratis is a hybrid user-and-kernel local storage management system that supports advanced storage features. The central concept of Stratis is a storage pool. 
This pool is created from one or more local disks or partitions, and volumes are created from the pool.


================================================================= /etc/fstab
 The fstab file typically lists all available disks and disk partitions, and indicates 
 how they are to be initialized or otherwise integrated into the overall system's file system


===================================================== how to check the filesystem type of a logical volume
lsblk -f
file -L -s /dev/mapper/d2-vmStorage


================================================================= FIND

find /opt/assets/ -type f -exec grep -Iq . {} \; -print        find file that contains text, when the others are empty



================================================================= RAID

 raid 0 - stripped, if we lose one disk all data will be lost
 raid 1 - redundant, mirror array, clone all data in all storages
 raid 5 - min 3 disk, has parity on each disk (used to rebuilt in lost of data), can lose 1 disc
 radi 6 - 4 discs, can lose 2 discs and still recovers data
 raid 10  - combination level 0 and 1
 
 sudo mdadm --create /dev/md0 --level=0 --raid-devices=3 /dev/vdc /dev/vdd /dev/vde
 sudo mkfs.ext4 /dev/md0
 sudo mdadm --stop /dev/md0    to stop or deactivate an array
 sudo mdadm --zero-superblock /dev/vdc /dev/vdd /dev/vde   to avoid the linux when bootup looking for arrays, if dont use this command linux will 
 built the array 
 sudo mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/vdc /dev/vdd --spare-devices=1 /dev/vde      add spare disk in an array
 add/remove more disks on the array /dev/md0
 sudo mdadm --manage /dev/md0 --add /dev/vde 
 sudo mdadm --manage /dev/md0 --remove /dev/vde 
 cat /proc/mdstat             look the status of array
 
 
================================================================ Setup user and group disk quotas for filesystems

quotas is a simple way to limit how much storage space each user or group can use

sudo dnf install quota
sudo vim /etc/fstab
      /dev/vdb1 /mybackups xfs ro,noexec 0 2
      /dev/vdb1 /mybackups xfs defaults,usrquota,grpquota 0 2   ->add defaults,usrquota,grpquota
 then save the file and reboot
 sudo systemctl reboot
 sudo quotacheck --create-files --user --group /dev/vdb2       it will create to files in a filesystem aquota.group and aquota.user
 sudo quotaon /mnt    this is when you mount in /mnt
 
 create a file with a specific size
 fallocate --length 100M /path/dir/100Mfile
 
 to edit quotas to a user
 sudo edquota --user <username>
 sudo quota --user <username>    if the user use more than capacity, it will have a grace period wwith that the user wont be able to write any data
 sudo quota --edit-period        to edit the grace period, soft limit
 sudo edquta --group <group_name>
 
 
====================================================================================== VDO
Virtual Data Optimizer (VDO) is a block virtualization technology that provides transparent deduplication of data. 
By eliminating redundant chunks of data, VDO can greatly reduce actual used disk capacity.




Create a physical volume for lvm on /dev/vdb with below command:


sudo pvcreate /dev/vdb

Create a new volume group named volume1 with /dev/vdb as a member:


sudo vgcreate volume1 /dev/vdb

Create a logical volume named storage using 100% of the free space on the volume group volume1:


sudo lvcreate -n storage -l 100%FREE volume1




Create an XFS filesystem on /dev/volume1/storage with below command:


sudo mkfs.xfs /dev/volume1/storage

Create a mount point at /storage as below:


sudo mkdir /storage/

Using an editor such as vi, edit /etc/fstab and add a line:


/dev/volume1/storage /storage xfs defaults 0 0

Mount the file system you have created with below command:

sudo mount -a



Create a new Stratis pool named kodekloud on /dev/vdd as below:


sudo stratis pool create kodekloud /dev/vdd

Create a new Stratis filesystem on the kodekloud pool, and name this filesystem kodekloud_files with below command:


sudo stratis fs create kodekloud kodekloud_files

With below command, create a new mount point at /kodekloud/ for this Stratis filesystem:


sudo mkdir /kodekloud/

Using an editor such as vi, edit /etc/fstab and add a line:


/dev/stratis/kodekloud/kodekloud_files /kodekloud xfs x-systemd-requires=stratisd.service 0 0

Mount the kodekloud_files filesystem to the mount point you created with below command:


sudo mount -a









Run the below command for default route information and save it to the file /home/bob/routes.txt:


ip route >> /home/bob/route.txt



To determine the PID for the sshd.service with below command:


systemctl status sshd.service

To get SELinux context label for the sshd process as below:

ps Z <PID>



Using an editor like vi edit the file /home/bob/context.txt and copy the line under LABEL from the previous command. Example as below:


system_u:system_r:sshd_t:s0-s0:c0.c1023




Determine the current SELinux mode on the system as save it to /home/bob/mode.txt:


getenforce > /home/bob/mode.txt




Determine the SELinux file context for the file at /home/bob/mystery as below:


ls -Z /home/bob/mystery

Save the file context label into /home/bob/file_context.txt using an editor like vi. For example, the context is similar to below text:


unconfined_u:object_r:user_home_t:s0




podman run -d --name my_web -p 1026:80 -v /home/bob/kodekloud:/usr/share/nginx/html:Z docker.io/library/nginx
podman run -d --name my_web -p 1026:80 -v /home/bob/kodekloud:/usr/share/nginx/html:Z docker.io/library/nginx



skopeo sync --src docker --dest dir docker.io/nginx:latest /home/bob/nginx
With Skopeo, you can inspect images on a remote registry without having to download the entire image with all its layers, 
making it a lightweight and modular solution for working with container images across different formats





grep -r [A-Z,a-z] /opt/assets/


#!/bin/bash
echo "Exiting with code 150."
exit 150


#!/bin/bash
if [ -f "/opt/assets2/asset75" ]
then
  echo "File exists. Making a copy."
  mkdir /home/bob/backups/
  cp /opt/assets2/asset75 /home/bob/backups/
else
  echo "File not found."
fi


#!/bin/bash
for file in $(ls /opt/assets3/)
  do
    echo Read file $file. >> /home/bob/read_log.txt
  done
  
  
  /dev/md0 /raid xfs defaults,usrquota,grpquota 0 0





Create a single partition on /dev/vde that uses the entire available disk space and set the partition type vfat file system as below:


sudo fdisk /dev/vde


Follow the below instructions after running the command:


Choose n for new

Choose p for primary, and use the entire disk space available.

Choose t for type for the partition.

Choose Lto list all codes and choose b for W95 FAT32.

Choose w to write the changes and exit.




Format the partition /dev/vde1 with a 32-bit vfat filesystem with below command:


sudo mkfs.vfat -F 32 /dev/vde1


Create a mount point at /vfat/ as below:


sudo mkdir /vfat/


Using an editor such as vi, edit /etc/fstab and add an entry as follow:


/dev/vde1 /vfat vfat defaults 0 0


Mount the filesystem to the /vfat/ as below:


sudo mount -a




/dev/stratis/web_storage/web_storage1 /mnt/web_storage xfs x-systemd.requires=stratisd.service 0 0


/dev/mapper/compressed /mnt/compressed xfs _netdev,x-systemd.device-timeout=0,x-systemd.requires=vdo.service 0 0



sudo ip route del 10.0.0.101




Using an editor like vi write the below line in /home/bob/grubcommand.txt file:


autorelabel=1




Which command would you use to restore the default SELinux file contexts to all files in the hypothetical directory /home/bob/context?

Write your answer in the file /home/bob/restore.txt.

info_outline
Solution
Using an editor like vi save the below command in /home/bob/restore.txt file:


restorecon -R /home/bob/context/
or 
restorecon -r /home/bob/context/




Create the appropriate directory and any necessary parent directories to store rootless systemd service files for the user bob.

info_outline
Solution
Using below command create the appropriate directory to store rootless systemd service files for the user bob :


mkdir -p ~/.config/systemd/user/







